% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/n-glycan-properties.R
\name{describe_n_glycans}
\alias{describe_n_glycans}
\title{Describe N-Glycans Properties}
\usage{
describe_n_glycans(glycans, strict = FALSE, parallel = FALSE)
}
\arguments{
\item{glycans}{A list of \code{glycan_graph} objects,
or a character vector of IUPAC-condensed structure strings.}

\item{strict}{A logical value. If \code{TRUE}, the glycan must have "concrete"
monosaccharides (e.g. "GlcNAc", "Man", "Gal") and linkage information.
If \code{FALSE}, the function is more lenient,
checking monosaacharide identities on the "simple" level (e.g. "H", "N", "F")
and ignoring linkage information.
Default is \code{FALSE}. This is preferred because in most cases the
structural resolution could not be high, but we known for sure the glycans are indeed N-glycans.}

\item{parallel}{A logical value. If \code{TRUE}, the function will use parallel processing.
Remember to call \code{\link[future:plan]{future::plan()}} before using this argument,
otherwise the function will still use sequential processing.}
}
\value{
A tibble with the following columns: "glycan_type", "bisecting",
"antennae", "core_fuc", "arm_fuc", "terminal_gal".
If the input glycans have names, the tibble will have a "glycan" column.
Otherwise, if IUPAC condensed strings are used, they will be used as the "glycan" column.
}
\description{
Extract key properties of N-glycans, including:
\itemize{
\item "glycan_type": N-glycan type: high mannose, hybrid, complex, or paucimannose.
\item "bisecting": Bisecting GlcNAc presence.
\item "antennae": Number of antennae.
\item "core_fuc": Number of core fucoses.
\item "arm_fuc": Number of arm fucoses.
\item "terminal_gal": Number of terminal galactoses.
}
}
\details{
This function is designed to work with N-glycans only.
If the glycans are not N-glycans, an error is thrown.
}
\section{Strictness}{
By default (\code{strict = FALSE}), the function is very lenient for motif checking.
It only checks the monosaccharide types on the "simple" level (e.g. "H", "N", "F"),
and ignores linkage information.
This is preferred because in most cases the structural resolution could not be high,
e.g. in most glycoproteomics studies.
However, the glycans are guaranteed to be N-glycans by the glycosylation sites.
In this case, we could make some assumptions about the glycan structures,
and extract the key properties.
For example, an \code{H-N} terminal motif is considered a terminal galactose.
If you have high-resolution glycan structures, you can set \code{strict = TRUE}.
}

\section{Enabling parallel processing}{
This function can spend a lot of time on large datasets (e.g. > 500 glycans).
To speed up, you can enable parallel processing by setting \code{parallel = TRUE}.
However, changing the argument to \code{TRUE} only set the function "ready"
for parallel processing.
You still need to call \code{\link[future:plan]{future::plan()}} to change the parallel backend.
For example, to use the "multisession" backend:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{library(future)
old_plan <- future::plan("multisession")  # Save the old plan
describe_n_glycans(glycans, parallel = TRUE)
future::plan(old_plan)  # Restore the old plan
}\if{html}{\out{</div>}}
}

\examples{
library(glyparse)
library(purrr)

glycans <- c(
  "(N(F)(N(H(H(N))(H(N(H))))))",
  "(N(N(H(H)(H(H)(H)))))",
  "(N(F)(N(H(H(N))(H(N(H(H)))))))",
  "(N(N(H(N)(H(N(H)(F)))(H(N(H)(F))(N(H)(F))))))",
  "(N(N(H(H(N(H(A))))(H(N(H(A)))))))"
)
glycans <- map(glycans, parse_pglyco_struc)
describe_n_glycans(glycans)

}
