% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vectorized.R
\name{has_motifs}
\alias{has_motifs}
\alias{have_motif}
\alias{have_motifs}
\alias{counts_motifs}
\alias{count_motif}
\alias{count_motifs}
\title{Vectorized Motif Checking Functions}
\usage{
has_motifs(glycan, motifs = NULL, alignments = NULL, ignore_linkages = FALSE)

have_motif(glycans, motif, alignment = NULL, ignore_linkages = FALSE)

have_motifs(
  glycans,
  motifs = NULL,
  alignments = NULL,
  ignore_linkages = FALSE,
  simplify = FALSE
)

counts_motifs(
  glycan,
  motifs = NULL,
  alignments = NULL,
  ignore_linkages = FALSE
)

count_motif(glycans, motif, alignment = NULL, ignore_linkages = FALSE)

count_motifs(
  glycans,
  motifs = NULL,
  alignments = NULL,
  ignore_linkages = FALSE,
  simplify = FALSE
)
}
\arguments{
\item{glycan}{A 'glycan_graph' object, or an IUPAC-condensed structure string.}

\item{motifs}{A list of 'glycan_graph' objects, a character vector of
IUPAC-condensed structure strings, or a character vector of known motif names.
If missing, all known motifs in the GlycoMotif GlyGen Collection will be used.}

\item{alignments}{A character vector of alignment names for the motifs,
either of the same length as \code{motifs}, or a single character string.
If not provided and \code{motifs} are known motif names or missing (using all known motifs),
the alignments in the GlycoMotif GlyGen Collection will be used.}

\item{ignore_linkages}{A logical value. If \code{TRUE}, linkages will be ignored in the comparison.}

\item{glycans}{A list of 'glycan_graph' objects, or a character vector of IUPAC-condensed structure strings.}

\item{motif}{A 'glycan_graph' object, an IUPAC-condensed structure string, or a known motif name.}

\item{alignment}{A single character, one of 'substructure', 'core', 'terminal' or 'whole'.
If not provided and \code{motif} is a known motif name,
the alignment in the GlycoMotif GlyGen Collection will be used.}

\item{simplify}{A logical value. Only used in \code{have_motifs()}.
If \code{TRUE}, drop columns (motifs) with all FALSE values. Default is \code{FALSE}.}
}
\value{
\code{has_motifs()}, \code{have_motif()}, \code{counts_motifs()}, and \code{count_motif()}
return a logical vector of the same length as the input motifs or glycans, respectively.
\code{have_motifs()} and \code{count_motifs()} return a matrix.
Rows are glycans and columns are motifs.

The dimension names are determined by the input arguments.
If \code{glycans} or \code{motifs} have names, they will be preserved in the result.
If not, but \code{glycans} or \code{motifs} are character vectors, they will be used as names.
}
\description{
Vectorized versions of \code{\link[=has_motif]{has_motif()}}:
\itemize{
\item \code{has_motifs()}: one glycan, many motifs.
\item \code{have_motif()}: many glycans, one motif.
\item \code{have_motifs()}: many glycans, many motifs.
}

Vectorized versions of \code{\link[=counts_motif]{counts_motif()}}:
\itemize{
\item \code{counts_motifs()}: one glycan, many motifs.
\item \code{count_motif()}: many glycans, one motif.
\item \code{count_motifs()}: many glycans, many motifs.
}

They can be told apart by English grammar:
\itemize{
\item Functions starting with "has" and "counts" work with one glycan,
"have" and "count" with multiple glycans.
\item Functions ending with "motif" work with one motif, "motifs" with multiple motifs.
}
}
\section{Why not \code{purrr}?}{
These functions have performance benefits over simply using \code{purrr} functions
on \code{has_motif()} and \code{counts_motif()}.
These two functions have many internal checks and conversions,
which can be redundant using \code{purrr}.
For example, when passing N motifs to \code{has_motifs()},
the checks and conversions will be performed N + 1 times
(N for the motifs and 1 for the glycan).
However, using \code{purrr::map_lgl(motifs, has_motif, glycan)}
will perform the checks and conversions N + N times.
The glycan will be processed repeatedly for each motif,
even thought N - 1 of them are redundant.
The situation is even worse if you are dealing with multiple glycans
and multiple motifs.
Using \code{purrr} functions will perform the checks and conversions
N * M times (N for the motifs and M for the glycans),
while using \code{have_motifs()} only need N + M times.
A huge save!
}

\section{Why so many?}{
You may wonder why we can't just make \code{has_motif()} and \code{counts_motif()} vectorized.
The reason is the the same between base "apply" family functions and \code{purrr} functions.
These vectorized functions have consistent and predictable return types.
\itemize{
\item \code{has_motif()} and \code{counts_motif()} always return a scalar.
\item \code{has_motifs()}, \code{have_motif()}, \code{counts_motifs()}, and \code{count_motif()} always return a vector.
\item \code{have_motifs()} and \code{count_motifs()} always return a matrix.
}
}

\section{More about arguments}{
When using known motifs in the GlycoMotif GlyGen Collection,
the best practice is to not provide the alignment arguments,
and let the function decide the alignment based on the motif name.
However, it is still possible to override the default alignments.
In this case, the user-provided alignments will be used,
but a warning will be issued.

Monosaccharide types must be the same within \code{glycans} or \code{motifs}.
However, an holistic obscurer monosaccharide type in \code{motifs} than in \code{glycans} is allowed.
}

\examples{
library(glyparse)

# Check if a glycan has the given motifs using names.
# Note that the `motifs` vector will become names of the result vector.
glycan <- "Gal(b1-3)GlcNAc(b1-3)Gal(b1-3)GalNAc(a1-"
has_motifs(glycan, c("O-Glycan core 1", "O-Glycan core 2"))

# Using IUPAC-condensed structure strings.
# Note that names of `motifs` are preserved in the result vector.
motifs <- c(M1 = "Gal(b1-3)GalNAc(a1-", M2 = "GlcNAc(b1-4)GlcNAc(a1-")
has_motifs(glycan, motifs)

# Or using 'glycan_graph' objects.
motifs <- list(
  M1 = parse_iupac_condensed("Gal(b1-3)GalNAc(a1-"),
  M2 = parse_iupac_condensed("GlcNAc(b1-4)GlcNAc(a1-")
)
has_motifs(glycan, motifs)

# If motifs are missing, use all known motifs in the
# GlycoMotif GlyGen Collection.
has_motifs(glycan)[1:5]

# Check if a list of glycans have the given motif.
glycans <- c(G1 = "Gal(b1-3)GalNAc(a1-", G2 = "GlcNAc(b1-4)GlcNAc(a1-")
have_motif(glycans, "O-Glycan core 1")

# Check if a list of glycans have the given motifs.
glycans <- c(G1 = "Gal(b1-3)GalNAc(a1-", G2 = "GlcNAc(b1-4)GlcNAc(a1-")
motifs <- c(M1 = "Gal(b1-", M2 = "GlcNAc(b1-")
have_motifs(glycans, motifs)

}
\seealso{
\code{\link[=has_motif]{has_motif()}}, \code{\link[=counts_motif]{counts_motif()}}
}
